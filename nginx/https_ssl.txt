SSL四次握手全过程

客户端                                                    服务器
ClientHello请求
(1)支持的协议版本，比如TLS 1.0版。
(2)一个客户端生成的随机数，稍后用于生成"对话密钥"。
(3)支持的加密方法，比如RSA公钥加密。
(4)支持的压缩方法。
                                                           SeverHello
							   (1)确认使用的加密通信协议版本.如果浏览器与服务器支持的版本不一致，服务器关闭加密通信 													(2)一个服务器生成的随机数,稍后用于生成"对话密钥"。
						           (3)确认使用的加密方法,比如RSA公钥加密。
		                                           (4)服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。
比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。(双向认证)

验证服务器证书(并从中取出公钥)
(1)一个随机数.该随机数用服务器公钥加密，防止被窃听。
(2)编码改变通知,表示随后的信息都将用双方商定的加密方法和密钥发送。
(3)客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验.

使用上面生成的三个随机数，生成会话密钥。             
                                                              生成会话密钥
							      (1)编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
                                                              (2)服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。



此时通信双方都有了这三个随机数。通过商定的加密方法根据三个随机数生成一个相同的会话密钥SessionSecret，用于之后的对称加密。

简单理解对称和非对称加密

对称加密
一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。
非对称加密
首先要有一对key，一个被称为private key私钥，一个成为public
key公钥，然后可以把你的public key分发给想给你传密文的用户，
然后用户使用该public key加密过得密文，只有使用你的private
key才能解密，也就是说，只要你自己保存好你的private key，
就能确保，别人想给你发的密文不被破解，所以你不用担心别人的密钥被盗，没关系。





抓包获取ssl握手过程
在客户端打开wireshark抓包。
过滤规则：(把访问xx.xx.com域名的包搞到)
ssl.handshake.extensions_server_name eq  xx.xx.com
