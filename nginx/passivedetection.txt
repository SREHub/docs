Nginx所谓的被动健康检测
	使用的是ngx_http_proxy_module 模块和ngx_http_upstream_module模块来达到检测后端是否可用的效果。
	ngx_http_proxy_module可以配置连接超时的时间：
	proxy_connect_timeout 设置与后端服务器建立连接的超时时间，默认为60S。
	proxy_read_timeout 设置从后端服务器读取响应的超时，指的是相邻两次读操作之间的最长时间间隔，默认为60s。
超时这一块要仔细研究一下。。。。

通过配置
proxy_next_upstream 设置在何种情况下一个失败的请求应该被发送到下一台机器，默认的是error timeout；
error    # 和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误
timeout  # 和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时
PS：只有当请求没有返回客户端之前，将请求转到另一台机器才是可行的。在发给给客户端的过程中出错，这类错误是不可
恢复的。

ngx_http_upstream_module模块
server指令：
max_fails=number 设定Nginx与服务器通信的尝试失败的次数。
在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不可用。
在下一个fail_timeout时间段，服务器不会再被尝试。 失败的尝试次数默认是1。
设为0就会停止统计尝试次数，认为服务器是一直可用的。 
你可以通过指令proxy_next_upstream、fastcgi_next_upstream和 memcached_next_upstream来配置什么是失败的尝试。 

fail_timeout=time 设定服务器被认为不可用的时间段以及统计失败尝试次数的时间段。
在这段时间中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。
默认情况下，该超时时间是10秒。在实际应用当中，如果你后端应用是能够快速重启的应用，比如nginx的话，自带的模块是可以满足需求的。
但是需要注意，如果后端有不健康节点，负载均衡器依然会先把该请求转发给该不健康节点，然后再转发给别的节点，这样就会浪费一次转发。
可是，如果当后端应用重启时，重启操作需要很久才能完成的时候就会有可能拖死整个负载均衡器。
此时，由于无法准确判断节点健康状态，导致请求handle住，出现假死状态，最终整个负载均衡器上的所有节点都无法正常响应请求。
并且ngx_http_upstream_module模块中的server指令中的max_fails参数设置值，也会和ngx_http_proxy_module 模块中的的proxy_next_upstream指令设置起冲突。
比如如果将max_fails设置为0，则代表不对后端服务器进行健康检查，这样还会使fail_timeout参数失效（即不起作用）。
此时，其实我们可以通过调节ngx_http_proxy_module 模块中的 proxy_connect_timeout 指令,通过将他们的值调低来发现不健康节点，进而将请求往健康节点转移。

现实中的例子，使用nginx作为代理节点，转发请求到后端服务器。
nginx本身对后端服务器的健康检测是用过判断后端连接错误和超时来判断后端服务器是否健康的。
设置 proxy_connect_timeout 10s;
设置 max_fails=3 fail_timeout=5s；
连接超时时间为10s,那么在5s内有3次超时则认为该节点不可用，但是显然这么设置，因为超时而被认为不可用是不可能成立的。
连接失败，我认为就是后端服务器连不上，或者端口不通等，在5s内三次连接不上则认为节点不可用。目前来看被动健康检查就
这一条成立。
